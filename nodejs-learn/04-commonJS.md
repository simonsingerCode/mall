## 一、node 入门

  ### 1. node 本身是基于 commonJS 模块规范设计的，所以模块是 node 的组成
    - 内置模块： node 中内置的 http  fs url querystring... 这些模块
    - 三方模块： 别人写好的可以拿过来直接用
    - 自定义模块：自己写的 js 文件

  ### 2. CommonJS 模块化设计思想
  ***

  ### 3. CommonJS 模块
    - 每一个js 就是要给模块(模块是私有的，里面的变量、函数等都是私有的，和其他的js文件中的内容是不冲突的)
    - CommonJS 中可以允许模块中的方法互相调用
  ***

  - **[导出]**
  #### CommonJS 给每一个模块中都设置了内置的变量/属性/方法
    1. module： 代表当前这个模块对象 [Object]
    2. module.exports： 用来导出当前模块 属性/方法的 [Object]
    3. exports: 是内置的一个"变量"，用来导出当前模块的属性和方法的，虽然和 module.exports 不是同一个东西，但是对应的值是同一个 (module.exports = export 值都是对象)

  #### **[导入]**
  **require('http');**  导入 内置/自定义 模块
  - require: 也是 CommonJS 提供的内置变量，用来导入模块的(其实导入的就是 module.exports 暴露出来的东西)
  - require 是一个同步操作，只有把导入的模块中的代码执行完毕，才能获取值，然后执行本模块下面的其他代码
  ***

  ### 4. CommonJS 的特点：
    1. 模块是私有的独立的，包括里面的所有东西也都是私有的，不会和其他模块产生干扰
    2. 模块可以多次加载，但只会在第一次加载时，运行一次，然后运行结果就被缓存了，如果后面在此加载，直接读取缓存结果。要想让模块再次运行，必须清楚缓存。
    3. 加载顺序，按照代码出现的顺序执行。加载模块是同步的，只有加载完成，才能执行后面的代码
    4. exports = {} 是无法到处内容的。默认和 module.exports 是同一个堆内存，但是这种操作，让 exports 指向一个新内存，而 module.exports 则不受影响；而 require 导入的是 module.exports 对应的堆内存；

  ### 5. 案例：
   1. A/B/C 三个模块  A中有一个sum方法：实现任意数求和；B中有一个avg方法：实现任意数求平均数；C中调去B中的avg，实现 12,23,34,45,56,67,78,89，求平均数
***

## 二、


## 三、
